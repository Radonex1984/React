function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * @public
 */
var StationSearchOrder = {
  name: 'name',
  url: 'url',
  homepage: 'homepage',
  favicon: 'favicon',
  tags: 'tags',
  country: 'country',
  state: 'state',
  language: 'language',
  votes: 'votes',
  codec: 'codec',
  bitrate: 'bitrate',
  lastCheckOK: 'lastCheckOK',
  lastCheckTime: 'lastCheckTime',
  clickTimeStamp: 'clickTimeStamp',
  clickCount: 'clickCount',
  clickTrend: 'clickTrend',
  random: 'random'
};
/**
 * @public
 */

var StationSearchType = {
  byUuid: 'byUuid',
  byName: 'byName',
  byNameExact: 'byNameExact',
  byCodec: 'byCodec',
  byCodexExact: 'byCodecExact',
  byCountry: 'byCountry',
  byCountryExact: 'byCountryExact',
  byCountryCodeExact: 'byCountryCodeExact',
  byState: 'byState',
  byStateExact: 'byStateExact',
  byLanguage: 'byLanguage',
  byLanguageExact: 'byLanguageExact',
  byTag: 'byTag',
  byTagExact: 'byTagExact'
};
/**
 * @public
 */

/**
 * Query the radio browser api.
 * @public
 */

class RadioBrowserApi {
  /**
   * Creates an instance of radio browser api.
   * @param appName - App name to be used as user agent header to indentify the calls to the API
   * @param hideBroken - Hide broken stations for all future API calls
   */
  constructor(appName, hideBroken = true) {
    this.appName = appName;
    this.hideBroken = hideBroken;
    this.baseUrl = void 0;
    this.fetchConfig = {
      method: 'GET',
      redirect: 'follow'
    };

    if (!appName) {
      throw new Error('appName is required');
    }

    this.fetchConfig.headers = {
      'user-agent': this.appName
    };
  }
  /**
   * Resolves API base url this will be the default for all class instances.
   * @param autoSet - Automatically set first resolved base url
   * @param config-  Fetch configuration
   * @returns Array of objects with the ip and name of the api server
   */


  resolveBaseUrl() {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var config = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};
      var result; // temporary fix for https cert error when in frontend
      // hardcode the server
      // https://github.com/segler-alex/radiobrowser-api-rust/issues/122

      if (typeof window !== 'undefined') {
        return [{
          ip: '45.77.62.161',
          name: 'fr1.api.radio-browser.info'
        }];
      }

      var response = yield fetch( // this should be https when the above issue is resolved
      'http://all.api.radio-browser.info/json/servers', config);

      if (response.ok) {
        result = yield response.json();
        return result;
      } else {
        throw response;
      }
    })();
  }
  /**
   * Sets base url for all api calls
   * @param url - Url to the api server
   */


  setBaseUrl(url) {
    this.baseUrl = url;
  }
  /**
   * Get current  base url
   * @returns Base url
   */


  getBaseUrl() {
    return this.baseUrl;
  }
  /**
   * Gets available countries
   * @param search - Search for country
   * @param query - Query params
   * @param fetchConfig - Fetch configuration
   * @returns Array of country results with the name of the station and station count
   */


  getCountries(search, query, fetchConfig) {
    var _this = this;

    return _asyncToGenerator(function* () {
      return _this.runRequest(_this.buildRequest('countries', search, query), fetchConfig);
    })();
  }
  /**
   * Gets countries by country code
   * @param search - Country code
   * @param query  - Query
   * @param fetchConfig - Fetch configuration
   * @returns Array of country results with the name of the station and station count
   */


  getCountryCodes(search, query, fetchConfig) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      search = search ? "".concat(search.toUpperCase()) : '';
      return _this2.runRequest(_this2.buildRequest('countrycodes', search, query), fetchConfig);
    })();
  }
  /**
   * Gets available codes
   * @param query - Query
   * @param fetchConfig -  Fetch configuration
   * @returns List of available codes
   */


  getCodecs(query, fetchConfig) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return _this3.runRequest(_this3.buildRequest('codecs', '', query), fetchConfig);
    })();
  }
  /**
   * Gets country states. States **should** be regions inside a country.
   * @param country - Limit state to particular country
   * @param query - Query
   * @param fetchConfig - Fetch configuration
   * @returns Array of country states
   */


  getCountryStates(country, query, fetchConfig) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      return _this4.runRequest(_this4.buildRequest('states', country, query), fetchConfig);
    })();
  }
  /**
   * Gets all available languages
   * @param language- Limit results to particular language
   * @param query -  Query
   * @param fetchConfig - Fetch configuration
   * @returns Array of language results
   */


  getLanguages(language, query, fetchConfig) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      return _this5.runRequest(_this5.buildRequest('languages', language, query), fetchConfig);
    })();
  }
  /**
   * Gets all available tags
   * @param tag - Limit results to particular tag
   * @param query - Query
   * @param fetchConfig - Fetch configuration
   * @returns List of tag results
   */


  getTags(tag, query, fetchConfig) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      tag = tag ? tag.toLowerCase() : ''; // empty string returns all tags

      return _this6.runRequest(_this6.buildRequest('tags', tag, query), fetchConfig);
    })();
  }
  /**
   * Gets stations by various available parameters
   * @param searchType - Parameter for the search
   * @param search - Search value for the parameter
   * @param query - Query
   * @param fetchConfig - Fetch configuration
   * @param removeDuplicates - remove duplicate stations
   * @returns Array of station results
   */


  getStationsBy(searchType, search, query, fetchConfig) {
    var _arguments2 = arguments,
        _this7 = this;

    return _asyncToGenerator(function* () {
      var removeDuplicates = _arguments2.length > 4 && _arguments2[4] !== undefined ? _arguments2[4] : false;

      if (!StationSearchType[searchType]) {
        throw new Error("search type does not exist: ".concat(searchType));
      }

      search = search ? search.toLowerCase() : ''; // http://fr1.api.radio-browser.info/{format}/stations/byuuid/{searchterm}

      var stations = yield _this7.runRequest(_this7.buildRequest("stations/".concat(searchType.toLowerCase()), search, query), fetchConfig);
      return _this7.normalizeStations(stations, removeDuplicates);
    })();
  }
  /**
   * Normalizes stations from the API response
   * @param stations - Array of station responses
   * @param removeDuplicates - remove duplicate stations
   * @returns Array of normalized stations
   */


  normalizeStations(stations) {
    var removeDuplicates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var result = [];
    var duplicates = {};

    for (var response of stations) {
      if (removeDuplicates) {
        var nameAndUrl = "".concat(response.name.toLowerCase().trim()).concat(response.url.toLowerCase().trim()); // guard against results having the same stations under different id's

        if (duplicates[nameAndUrl]) continue;
        duplicates[nameAndUrl] = true;
      }

      var station = {
        changeId: response.changeuuid,
        id: response.stationuuid,
        name: response.name,
        url: response.url,
        urlResolved: response.url_resolved,
        homepage: response.homepage,
        favicon: response.favicon,
        country: response.country,
        countryCode: response.countrycode,
        state: response.state,
        votes: response.votes,
        codec: response.codec,
        bitrate: response.bitrate,
        clickCount: response.clickcount,
        clickTrend: response.clicktrend,
        hls: Boolean(response.hls),
        lastCheckOk: Boolean(response.lastcheckok),
        lastChangeTime: new Date(response.lastchangetime),
        lastCheckOkTime: new Date(response.lastcheckoktime),
        clickTimestamp: new Date(response.clicktimestamp),
        lastLocalCheckTime: new Date(response.lastlocalchecktime),
        language: response.language.split(','),
        lastCheckTime: new Date(response.lastchecktime),
        tags: [...new Set(response.tags.split(','))].filter(tag => tag.length > 0 && tag.length < 10) // drop duplicates and tags over 10 characters

      };
      result.push(station);
    }

    return result;
  }
  /**
   * Gets all available stations. Please note that if results
   * are not limited somehow, they can be huge (size in MB)
   * @param query - Query
   * @param fetchConfig - Fetch configuration
   * @param removeDuplicates - remove duplicate stations
   * @returns Array of all available stations
   */


  getAllStations(query, fetchConfig) {
    var _arguments3 = arguments,
        _this8 = this;

    return _asyncToGenerator(function* () {
      var removeDuplicates = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : false;
      var stations = yield _this8.runRequest(_this8.buildRequest('stations', '', query), fetchConfig);
      return _this8.normalizeStations(stations, removeDuplicates);
    })();
  }
  /**
   * Searches stations by particular params
   * @param query - Query
   * @param fetchConfig - Fetch configuration
   * @param removeDuplicates - remove duplicate stations
   * @returns Array of station results
   */


  searchStations(query, fetchConfig) {
    var _arguments4 = arguments,
        _this9 = this;

    return _asyncToGenerator(function* () {
      var removeDuplicates = _arguments4.length > 2 && _arguments4[2] !== undefined ? _arguments4[2] : false;
      var stations = yield _this9.runRequest(_this9.buildRequest('stations/search', undefined, query), fetchConfig);
      return _this9.normalizeStations(stations, removeDuplicates);
    })();
  }
  /**
   * Gets stations by clicks. Stations with the highest number of clicks are most popular
   * @param limit - Limit the number of returned stations
   * @param fetchConfig - Fetch configuration
   * @returns Array of stations
   */


  getStationsByClicks(limit, fetchConfig) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      return _this10.resolveGetStations('topclick', limit, fetchConfig);
    })();
  }
  /**
   * Gets stations by votes. Returns most voted stations
   * @param limit - Limit the number of returned stations
   * @param fetchConfig - Fetch configuration
   * @returns Array of stations
   */


  getStationsByVotes(limit, fetchConfig) {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      return _this11.resolveGetStations('topvote', limit, fetchConfig);
    })();
  }
  /**
   * Gets stations by recent clicks. They are basically most recently listened stations.
   * @param limit - Limit the number of returned stations
   * @param fetchConfig - Fetch configuration
   * @returns Array of stations
   */


  getStationsByRecentClicks(limit, fetchConfig) {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      return _this12.resolveGetStations('lastclick', limit, fetchConfig);
    })();
  }
  /**
   * Sends click for the station. This method should be used when user starts to listen to the station.
   * @param id - Station id
   * @param fetchConfig  - Fetch configuration
   * @returns Station click object
   */


  sendStationClick(id, fetchConfig) {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      return _this13.runRequest(_this13.buildRequest('url', id, undefined, false), fetchConfig);
    })();
  }
  /**
   * Votes for station. This method should be used when user adds the station to favourites etc..
   * @param id - Station id
   * @param fetchConfig - Fetch configuration
   * @returns Station vote object
   */


  voteForStation(id, fetchConfig) {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      return _this14.runRequest(_this14.buildRequest('vote', id), fetchConfig);
    })();
  }
  /**
   * Gets stations by station id
   * @param ids - Array of station id's
   * @param fetchConfig - Fetch configuration
   * @returns Array of stations
   */


  getStationsById(ids, fetchConfig) {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      var stationsIds = ids.join(',');
      var stations = yield _this15.runRequest(_this15.buildRequest("stations/byuuid?uuids=".concat(stationsIds), undefined, undefined, false), fetchConfig);
      return _this15.normalizeStations(stations);
    })();
  }
  /**
   * Gets station by station url
   * @param url - Station url
   * @param fetchConfig - Fetch configuration
   * @returns Array of stations
   */


  getStationByUrl(url, fetchConfig) {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      var stations = yield _this16.runRequest(_this16.buildRequest("stations/byurl/".concat(url), undefined, undefined, false), fetchConfig);
      return _this16.normalizeStations(stations);
    })();
  }

  resolveGetStations(endPoint, limit, fetchConfig) {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      var limitStations = limit ? "/".concat(limit) : '';
      var stations = yield _this17.runRequest(_this17.buildRequest("stations/".concat(endPoint).concat(limitStations), undefined, undefined, false), fetchConfig);
      return _this17.normalizeStations(stations);
    })();
  }
  /**
   * Builds request to the API
   * @param endPoint - API endpoint
   * @param search - Search term
   * @param query - Query
   * @param addHideBrokenParam - Hide broken stations from the results
   * @returns Built request string
   */


  buildRequest(endPoint, search, query) {
    var addHideBrokenParam = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    search = search ? "/".concat(encodeURIComponent(search)) : '';
    var queryCopy;

    if (query) {
      queryCopy = _objectSpread2({}, query);

      if ('tagList' in queryCopy && Array.isArray(queryCopy.tagList)) {
        queryCopy.tagList = [...queryCopy.tagList];
      }

      if (addHideBrokenParam && typeof queryCopy.hideBroken === 'undefined') {
        queryCopy.hideBroken = this.hideBroken;
      }
    }

    var queryParams = queryCopy ? this.createQueryParams(queryCopy) : '';
    return "".concat(endPoint).concat(search).concat(queryParams);
  }
  /**
   * Fires of the request to the API
   * @param url - Request url
   * @param fetchConfig - Fetch configuration
   * @returns Fetch response
   */


  runRequest(url) {
    var _arguments5 = arguments,
        _this18 = this;

    return _asyncToGenerator(function* () {
      var fetchConfig = _arguments5.length > 1 && _arguments5[1] !== undefined ? _arguments5[1] : {};

      var finalConfig = _objectSpread2(_objectSpread2(_objectSpread2({}, _this18.fetchConfig), fetchConfig), {}, {
        headers: _objectSpread2(_objectSpread2({}, _this18.fetchConfig.headers), fetchConfig.headers)
      });

      if (!_this18.baseUrl) {
        var results = yield _this18.resolveBaseUrl();
        var random = Math.floor(Math.random() * results.length);
        _this18.baseUrl = "https://".concat(results[random].name);
      }

      var response = yield fetch("".concat(_this18.baseUrl, "/json/").concat(url), finalConfig);

      if (response.ok) {
        return response.json();
      } else {
        throw response;
      }
    })();
  }
  /**
   * Encodes query parameters
   * @param params - Object that represents paramters as key value pairs
   * @returns  String of encoded query parameters
   */


  createQueryParams(params) {
    var result = '';

    if (params) {
      for (var [_key, value] of Object.entries(params)) {
        result += "&".concat(_key, "=").concat(encodeURIComponent(value));
      }
    }

    return result ? "?".concat(result.slice(1).toLowerCase()) : '';
  }

}
RadioBrowserApi.version = "5.0.0";

export { RadioBrowserApi, StationSearchOrder, StationSearchType };
//# sourceMappingURL=index.esm.js.map
